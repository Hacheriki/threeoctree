!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t.THREE||{},t.THREE)}(this,(function(t,e){"use strict";function s(t){return!isNaN(t)&&isFinite(t)}class i{constructor(t,s){this.useFaces=!1,this.useVertices=!1,this.object=t,s instanceof e.Vector3?(this.vertices=s,this.useVertices=!0):s&&(this.faces=s,this.useFaces=!0),this.radius=0,this.position=new e.Vector3,this.update(),this.positionLast=this.position.clone()}update(){if(this.faces){const{center:t,radius:e}=this.getFace3BoundingSphere(this.object,this.faces);this.radius=e,this.position.copy(t).applyMatrix4(this.object.matrixWorld)}else this.vertices?(this.object.geometry.boundingSphere||this.object.geometry.computeBoundingSphere(),this.radius=this.object.geometry.boundingSphere.radius,this.position.copy(this.vertices).applyMatrix4(this.object.matrixWorld)):(this.object.geometry.boundingSphere||this.object.geometry.computeBoundingSphere(),this.radius=this.object.geometry.boundingSphere.radius,this.position.copy(this.object.geometry.boundingSphere.center).applyMatrix4(this.object.matrixWorld));this.radius=this.radius*Math.max(this.object.scale.x,this.object.scale.y,this.object.scale.z)}getFace3BoundingSphere(t,s){let i,o,n;const r=t.geometry.getAttribute("position");i=(new e.Vector3).fromBufferAttribute(r,s.a),o=(new e.Vector3).fromBufferAttribute(r,s.b),n=(new e.Vector3).fromBufferAttribute(r,s.c);const h=new e.Vector3,c=(new e.Vector3).addVectors(i,o).add(n).divideScalar(3);return{center:c,radius:Math.max(h.subVectors(c,i).length(),h.subVectors(c,o).length(),h.subVectors(c,n).length())}}}class o{constructor(t={}){this.objects=[],this.nodesIndices=[],this.nodesByIndex={},t.tree instanceof n?this.tree=t.tree:t.parent instanceof o||(t.root=this,this.tree=new n(t)),this.id=this.tree.nodeCount++,this.position=t.position instanceof e.Vector3?t.position:new e.Vector3,this.radius=t.radius>0?t.radius:1,this.indexOctant=t.indexOctant,this.depth=0,this.reset(),this.setParent(t.parent),this.overlap=this.radius*this.tree.overlapPct,this.radiusOverlap=this.radius+this.overlap,this.left=this.position.x-this.radiusOverlap,this.right=this.position.x+this.radiusOverlap,this.bottom=this.position.y-this.radiusOverlap,this.top=this.position.y+this.radiusOverlap,this.back=this.position.z-this.radiusOverlap,this.front=this.position.z+this.radiusOverlap,this.tree.scene&&(this.visual=new e.Mesh(this.tree.visualGeometry,this.tree.visualMaterial),this.visual.scale.set(2*this.radiusOverlap,2*this.radiusOverlap,2*this.radiusOverlap),this.visual.position.copy(this.position),this.tree.scene.add(this.visual))}setParent(t){t!==this&&this.parent!==t&&(this.parent=t,this.updateProperties())}updateProperties(){this.parent instanceof o?(this.tree=this.parent.tree,this.depth=this.parent.depth+1):this.depth=0;for(let t=0,e=this.nodesIndices.length;t<e;t++)this.nodesByIndex[this.nodesIndices[t]].updateProperties()}reset(t=!1,e=!1){const s=this.nodesIndices||[],i=this.nodesByIndex;this.objects=[],this.nodesIndices=[],this.nodesByIndex={};for(let o=0,n=s.length;o<n;o++){const n=i[s[o]];n.setParent(void 0),!0===t&&n.reset(t,e)}!0===e&&this.visual&&this.visual.parent&&this.visual.parent.remove(this.visual)}addNode(t,e){t.indexOctant=e,-1===this.nodesIndices.indexOf(e)&&this.nodesIndices.push(e),this.nodesByIndex[e]=t,t.parent!==this&&t.setParent(this)}removeNode(t){const e=this.nodesIndices.indexOf(t);this.nodesIndices.splice(e,1);const s=this.nodesByIndex[t];delete this.nodesByIndex[t],s.parent===this&&s.setParent(void 0)}addObject(t){const e=this.getOctantIndex(t);if(e>-1&&this.nodesIndices.length>0){this.branch(e).addObject(t)}else if(e<-1&&this.parent instanceof o)this.parent.addObject(t);else{-1===this.objects.indexOf(t)&&this.objects.push(t),t.node=this,this.checkGrow()}}addObjectWithoutCheck(t){for(let e=0,s=t.length;e<s;e++){const s=t[e];this.objects.push(s),s.node=this}}removeObject(t){const{nodesRemovedFrom:e,objectsDataRemoved:s}=this.removeObjectRecursive(t,{searchComplete:!1,nodesRemovedFrom:[],objectsDataRemoved:[]});if(e.length>0)for(let t=0,s=e.length;t<s;t++)e[t].shrink();return s}removeObjectRecursive(t,e){let s=!1;if(t instanceof i){const i=this.objects.indexOf(t);-1!==i&&(this.objects.splice(i,1),t.node=void 0,e.objectsDataRemoved.push(t),e.searchComplete=s=!0)}else for(let i=this.objects.length-1;i>-1;i--){const o=this.objects[i];if(o.object===t&&(this.objects.splice(i,1),o.node=void 0,e.objectsDataRemoved.push(o),s=!0,!o.faces&&!o.vertices)){e.searchComplete=!0;break}}if(s&&e.nodesRemovedFrom.push(this),!e.searchComplete)for(let s=0,i=this.nodesIndices.length;s<i;s++){if((e=this.nodesByIndex[this.nodesIndices[s]].removeObjectRecursive(t,e)).searchComplete)break}return e}checkGrow(){this.objects.length>this.tree.objectsThreshold&&this.tree.objectsThreshold>0&&this.grow()}grow(){const t=[],e=[],s=[],i=[];let o=[];for(let n=0,r=this.objects.length;n<r;n++){const r=this.objects[n],h=this.getOctantIndex(r);h>-1?(s.push(r),i.push(h)):h<-1?(t.push(r),e.push(h)):o.push(r)}s.length>0&&(o=o.concat(this.split(s,i))),t.length>0&&(o=o.concat(this.expand(t,e))),this.objects=o,this.checkMerge()}split(t,e){let s;if(this.depth<this.tree.depthMax){e=e||[],s=[];for(let i=0,o=(t=t||this.objects).length;i<o;i++){const o=t[i],n=e[i];if(n>-1){this.branch(n).addObject(o)}else s.push(o)}t===this.objects&&(this.objects=s)}else s=this.objects;return s}branch(t){if(this.nodesByIndex[t]instanceof o)return this.nodesByIndex[t];{const s=.5*this.radiusOverlap,i=s-s*this.tree.overlapPct,n=new e.Vector3(1&t?i:-i,2&t?i:-i,4&t?i:-i).add(this.position),r=new o({tree:this.tree,parent:this,position:n,radius:s,indexOctant:t});return this.addNode(r,t),r}}expand(t,s){const i=this.tree.INDEX_OUTSIDE_MAP;let n;if(this.tree.root.getDepthEnd()<this.tree.depthMax){t=t||this.objects,s=s||[],n=[];const r=[];for(let t=0,e=i.length;t<e;t++)i[t].count=0;for(let e=0,o=t.length;e<o;e++){const o=t[e],h=s[e];if(h<-1){const t=-h-this.tree.INDEX_OUTSIDE_OFFSET;t&this.tree.FLAG_POS_X?i[this.tree.INDEX_OUTSIDE_POS_X].count++:t&this.tree.FLAG_NEG_X&&i[this.tree.INDEX_OUTSIDE_NEG_X].count++,t&this.tree.FLAG_POS_Y?i[this.tree.INDEX_OUTSIDE_POS_Y].count++:t&this.tree.FLAG_NEG_Y&&i[this.tree.INDEX_OUTSIDE_NEG_Y].count++,t&this.tree.FLAG_POS_Z?i[this.tree.INDEX_OUTSIDE_POS_Z].count++:t&this.tree.FLAG_NEG_Z&&i[this.tree.INDEX_OUTSIDE_NEG_Z].count++,r.push(o)}else n.push(o)}if(r.length>0){const t=i.slice(0);t.sort(((t,e)=>e.count-t.count));const s=t[0],n=1|s.index;let h=t[1],c=t[2];const a=(1|h.index)!==n?h:c,d=1|a.index;h=t[2],c=t[3];const l=t[4],u=1|h.index,p=1|c.index,f=u!==n&&u!==d?h:p!==n&&p!==d?c:l,_=s.x+a.x+f.x,O=s.y+a.y+f.y,b=s.z+a.z+f.z,I=this.getOctantIndexFromPosition(_,O,b),E=this.getOctantIndexFromPosition(-_,-O,-b),D=this.overlap,j=this.radius,g=this.tree.overlapPct>0?D/(.5*this.tree.overlapPct*(1+this.tree.overlapPct)):2*j,x=g+g*this.tree.overlapPct-(j+D),S=new e.Vector3(1&I?x:-x,2&I?x:-x,4&I?x:-x);S.add(this.position);const N=new o({tree:this.tree,position:S,radius:g});N.addNode(this,E),this.tree.setRoot(N);for(let t=0,e=r.length;t<e;t++)this.tree.root.addObject(r[t])}t===this.objects&&(this.objects=n)}else n=t;return n}shrink(){this.checkMerge(),this.tree.root.checkContract()}checkMerge(){let t,e=this;for(;e.parent instanceof o&&e.getObjectsCountEnd()<this.tree.objectsThreshold;)t=e,e=e.parent;e!==this&&e.merge(t)}merge(t){for(let e=0,s=(t=t?Array.isArray(t)?t:[t]:[]).length;e<s;e++){const s=t[e];this.addObjectWithoutCheck(s.getObjectsEnd()),s.reset(!0,!0),this.removeNode(s.indexOctant)}this.checkMerge()}checkContract(){if(this.nodesIndices.length>0){let t,e=0,s=this.objects.length;for(let i=0,n=this.nodesIndices.length;i<n;i++){const n=this.nodesByIndex[this.nodesIndices[i]],r=n.getObjectsCountEnd();s+=r,t&&t instanceof o&&!(r>e)||(t=n,e=r)}s-=e,s<this.tree.objectsThreshold&&t instanceof o&&this.contract(t)}}contract(t){for(let e=0,s=this.nodesIndices.length;e<s;e++){const s=this.nodesByIndex[this.nodesIndices[e]];s!==t&&(t.addObjectWithoutCheck(s.getObjectsEnd()),s.reset(!0,!0))}t.addObjectWithoutCheck(this.objects),this.reset(!1,!0),this.tree.setRoot(t),t.checkContract()}getOctantIndex(t){let e,s;t instanceof i?(e=t.radius,s=t.position,t.positionLast.copy(s)):t instanceof o&&(s=t.position,e=0);const n=s.x-this.position.x,r=s.y-this.position.y,h=s.z-this.position.z,c=Math.abs(n),a=Math.abs(r),d=Math.abs(h);let l=0;if(Math.max(c,a,d)+e>this.radiusOverlap)return c+e>this.radiusOverlap&&(l^=n>0?this.tree.FLAG_POS_X:this.tree.FLAG_NEG_X),a+e>this.radiusOverlap&&(l^=r>0?this.tree.FLAG_POS_Y:this.tree.FLAG_NEG_Y),d+e>this.radiusOverlap&&(l^=h>0?this.tree.FLAG_POS_Z:this.tree.FLAG_NEG_Z),t.indexOctant=-l-this.tree.INDEX_OUTSIDE_OFFSET,t.indexOctant;if(n-e>-this.overlap)l|=1;else if(!(n+e<this.overlap))return t.indexOctant=this.tree.INDEX_INSIDE_CROSS,t.indexOctant;if(r-e>-this.overlap)l|=2;else if(!(r+e<this.overlap))return t.indexOctant=this.tree.INDEX_INSIDE_CROSS,t.indexOctant;if(h-e>-this.overlap)l|=4;else if(!(h+e<this.overlap))return t.indexOctant=this.tree.INDEX_INSIDE_CROSS,t.indexOctant;return t.indexOctant=l,t.indexOctant}getOctantIndexFromPosition(t,e,s){let i=0;return t>0&&(i|=1),e>0&&(i|=2),s>0&&(i|=4),i}search(t,e,s,i,o){if(!0===(i?this.intersectRay(t,i,e,o):this.intersectSphere(t,e))){s=s.concat(this.objects);for(let o=0,n=this.nodesIndices.length;o<n;o++){s=this.nodesByIndex[this.nodesIndices[o]].search(t,e,s,i)}}return s}intersectSphere(t,e){let s=e*e;const i=t.x,o=t.y,n=t.z;return i<this.left?s-=Math.pow(i-this.left,2):i>this.right&&(s-=Math.pow(i-this.right,2)),o<this.bottom?s-=Math.pow(o-this.bottom,2):o>this.top&&(s-=Math.pow(o-this.top,2)),n<this.back?s-=Math.pow(n-this.back,2):n>this.front&&(s-=Math.pow(n-this.front,2)),s>=0}intersectRay(t,s,i,o){void 0===o&&(o=new e.Vector3(1,1,1).divide(s));const n=(this.left-t.x)*o.x,r=(this.right-t.x)*o.x,h=(this.bottom-t.y)*o.y,c=(this.top-t.y)*o.y,a=(this.back-t.z)*o.z,d=(this.front-t.z)*o.z,l=Math.min(Math.min(Math.max(n,r),Math.max(h,c)),Math.max(a,d));if(l<0)return!1;const u=Math.max(Math.max(Math.min(n,r),Math.min(h,c)),Math.min(a,d));return!(u>l||u>i)}getDepthEnd(t){if(this.nodesIndices.length>0)for(let e=0,s=this.nodesIndices.length;e<s;e++){t=this.nodesByIndex[this.nodesIndices[e]].getDepthEnd(t)}else t=!t||this.depth>t?this.depth:t;return t}getNodeCountEnd(){return this.tree.root.getNodeCountRecursive()+1}getNodeCountRecursive(){let t=this.nodesIndices.length;for(let e=0,s=this.nodesIndices.length;e<s;e++)t+=this.nodesByIndex[this.nodesIndices[e]].getNodeCountRecursive();return t}getObjectsEnd(t){t=(t||[]).concat(this.objects);for(let e=0,s=this.nodesIndices.length;e<s;e++){t=this.nodesByIndex[this.nodesIndices[e]].getObjectsEnd(t)}return t}getObjectsCountEnd(){let t=this.objects.length;for(let e=0,s=this.nodesIndices.length;e<s;e++)t+=this.nodesByIndex[this.nodesIndices[e]].getObjectsCountEnd();return t}getObjectsCountStart(){let t=this.objects.length,e=this.parent;for(;e instanceof o;)t+=e.objects.length,e=e.parent;return t}toConsole(t){t="string"==typeof t?t:"   ",console.log(this.parent?t+" octree NODE > ":" octree ROOT > ",this," // id: ",this.id," // indexOctant: ",this.indexOctant," // position: ",this.position.toArray().join(" ")," // radius: ",this.radius," // depth: ",this.depth),console.log(this.parent?t+" ":" ","+ objects ( ",this.objects.length," ) ",this.objects),console.log(this.parent?t+" ":" ","+ children ( ",this.nodesIndices.length," ) ",this.nodesIndices,this.nodesByIndex);for(let e=0,s=this.nodesIndices.length;e<s;e++){this.nodesByIndex[this.nodesIndices[e]].toConsole(t+"   ")}}}class n{constructor(t={}){this.nodeCount=0,this.INDEX_INSIDE_CROSS=-1,this.INDEX_OUTSIDE_OFFSET=2,this.INDEX_OUTSIDE_MAP=[],this.utilVec31Search=new e.Vector3,this.utilVec32Search=new e.Vector3,this.objects=[],this.objectsMap={},this.objectsData=[],this.objectsDeferred=[],this.undeferred=!1,t.tree=this,this.INDEX_OUTSIDE_POS_X=s(t.INDEX_OUTSIDE_POS_X)?t.INDEX_OUTSIDE_POS_X:0,this.INDEX_OUTSIDE_NEG_X=s(t.INDEX_OUTSIDE_NEG_X)?t.INDEX_OUTSIDE_NEG_X:1,this.INDEX_OUTSIDE_POS_Y=s(t.INDEX_OUTSIDE_POS_Y)?t.INDEX_OUTSIDE_POS_Y:2,this.INDEX_OUTSIDE_NEG_Y=s(t.INDEX_OUTSIDE_NEG_Y)?t.INDEX_OUTSIDE_NEG_Y:3,this.INDEX_OUTSIDE_POS_Z=s(t.INDEX_OUTSIDE_POS_Z)?t.INDEX_OUTSIDE_POS_Z:4,this.INDEX_OUTSIDE_NEG_Z=s(t.INDEX_OUTSIDE_NEG_Z)?t.INDEX_OUTSIDE_NEG_Z:5,this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_POS_X]={index:this.INDEX_OUTSIDE_POS_X,count:0,x:1,y:0,z:0},this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_NEG_X]={index:this.INDEX_OUTSIDE_NEG_X,count:0,x:-1,y:0,z:0},this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_POS_Y]={index:this.INDEX_OUTSIDE_POS_Y,count:0,x:0,y:1,z:0},this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_NEG_Y]={index:this.INDEX_OUTSIDE_NEG_Y,count:0,x:0,y:-1,z:0},this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_POS_Z]={index:this.INDEX_OUTSIDE_POS_Z,count:0,x:0,y:0,z:1},this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_NEG_Z]={index:this.INDEX_OUTSIDE_NEG_Z,count:0,x:0,y:0,z:-1},this.FLAG_POS_X=1<<this.INDEX_OUTSIDE_POS_X+1,this.FLAG_NEG_X=1<<this.INDEX_OUTSIDE_NEG_X+1,this.FLAG_POS_Y=1<<this.INDEX_OUTSIDE_POS_Y+1,this.FLAG_NEG_Y=1<<this.INDEX_OUTSIDE_NEG_Y+1,this.FLAG_POS_Z=1<<this.INDEX_OUTSIDE_POS_Z+1,this.FLAG_NEG_Z=1<<this.INDEX_OUTSIDE_NEG_Z+1,this.scene=t.scene,this.scene&&(this.visualGeometry=new e.BoxGeometry(1,1,1),this.visualMaterial=new e.MeshBasicMaterial({color:16711782,wireframe:!0,wireframeLinewidth:1})),this.depthMax=s(t.depthMax)?t.depthMax:1/0,this.objectsThreshold=s(t.objectsThreshold)?t.objectsThreshold:8,this.overlapPct=s(t.overlapPct)?t.overlapPct:.15,this.undeferred=t.undeferred||!1,this.root=t.root instanceof o?t.root:new o(t)}update(){if(this.objectsDeferred.length>0){for(let t=0,e=this.objectsDeferred.length;t<e;t++){const{object:e,options:s}=this.objectsDeferred[t];this.addDeferred(e,s)}this.objectsDeferred.length=0}}add(t,e){this.undeferred?(this.updateObject(t),this.addDeferred(t,e)):this.objectsDeferred.push({object:t,options:e})}addDeferred(t,s){if(t instanceof i&&(t=t.object),!(t.geometry instanceof e.BufferGeometry))throw new Error("Unsupported geometry type: Use BufferGeometry!");if(t.uuid||(t.uuid=e.MathUtils.generateUUID()),!this.objectsMap[t.uuid]){this.objects.push(t),this.objectsMap[t.uuid]=t;let i=!1,o=!1;if(s&&(i=s.useFaces,o=s.useVertices),!0===o){if(t.geometry instanceof e.BufferGeometry&&t.geometry.attributes.position instanceof e.BufferAttribute){const s=t.geometry.attributes.position;for(let i=0,o=s.count;i<o;i++)this.addObjectData(t,(new e.Vector3).fromBufferAttribute(s,i))}}else if(!0===i){const s=t.geometry.attributes.position,i=t.geometry.index;if(i)for(let s=0,o=i.count;s<o;s+=3)this.addObjectData(t,{a:s,b:s+1,c:s+2,normal:new e.Vector3,materialIndex:0});else for(let i=0,o=s.count;i<o;i+=3)this.addObjectData(t,{a:i,b:i+1,c:i+2,normal:new e.Vector3,materialIndex:0})}else this.addObjectData(t)}}addObjectData(t,e){const s=new i(t,e);this.objectsData.push(s),this.root.addObject(s)}remove(t){if(t instanceof i&&(t=t.object),this.objectsMap[t.uuid]){this.objectsMap[t.uuid]=void 0;const e=this.objects.indexOf(t);if(-1!==e){this.objects.splice(e,1);const s=this.root.removeObject(t);for(let t=0,e=s.length;t<e;t++){const e=s[t],i=this.objectsData.indexOf(e);-1!==i&&this.objectsData.splice(i,1)}}}else if(this.objectsDeferred.length>0){const e=function(t,e,s){for(let i=0,o=t.length;i<o;i++)if(t[i][e]===s)return i;return-1}(this.objectsDeferred,"object",t);-1!==e&&this.objectsDeferred.splice(e,1)}}extend(t){if(t instanceof n){const e=t.objectsData;for(let t=0,s=e.length;t<s;t++){const s=e[t];this.add(s,{useFaces:s.useFaces,useVertices:s.useVertices})}}}rebuild(){const t=[];for(let e=0,s=this.objectsData.length;e<s;e++){const s=this.objectsData[e],i=s.node;if(s.update(),i instanceof o&&!s.positionLast.equals(s.position)){const e=s.indexOctant;i.getOctantIndex(s)!==e&&t.push(s)}}for(let e=0,s=t.length;e<s;e++){const s=t[e];s.node.removeObject(s),this.root.addObject(s)}}updateObject(t){t instanceof i&&(t=t.object);const e=[t];let s,o=t.parent;for(;o;)e.push(o),o=o.parent;for(let t=0,i=e.length;t<i;t++)o=e[t],o.matrixWorldNeedsUpdate&&(s=o);void 0!==s&&s.updateMatrixWorld()}search(t,s,i,o){let n,r=[].concat(this.root.objects);s>0||(s=Number.MAX_VALUE),o instanceof e.Vector3&&(o=o.clone().normalize(),n=new e.Vector3(1,1,1).divide(o));for(let e=0,i=this.root.nodesIndices.length;e<i;e++){r=this.root.nodesByIndex[this.root.nodesIndices[e]].search(t,s,r,o,n)}if(!0===i){const t=[],e=[];let s;for(let i=0,o=r.length;i<o;i++){const o=r[i],n=o.object,h=e.indexOf(n);-1===h?(s={object:n,faces:[],vertices:[]},t.push(s),e.push(n)):s=t[h],o.faces?s.faces.push(o.faces):s.vertices.push(o.vertices)}return t}return r}findClosestVertex(t,e){const s=this.search(t,e,!0);if(!s[0])return null;const i=s[0].object,o=s[0].vertices;if(0===o.length)return null;let n,r=null;const h=i.worldToLocal(t.clone());for(let t=0,s=o.length;t<s;t++)n=o[t].distanceTo(h),n>e||(e=n,r=o[t]);return null===r?null:i.localToWorld(r.clone())}setRoot(t){t instanceof o&&(this.root=t,this.root.updateProperties())}getDepthEnd(){return this.root.getDepthEnd()}getNodeCountEnd(){return this.root.getNodeCountEnd()}getObjectCountEnd(){return this.root.getObjectsCountEnd()}toConsole(){this.root.toConsole()}}const r=new e.Vector3,h=new e.Vector3,c=new e.Vector3,a=new e.Vector3,d=new e.Vector3;class l extends e.Raycaster{intersectOctreeObject(t,s=!0,i=[]){if(t instanceof e.Object3D)i.push(...this.intersectObject(t,s));else if(t.object instanceof e.Mesh){const e=t.object,o=e.geometry.getAttribute("position");if(Array.isArray(t.faces)&&t.faces.length>0)for(const s of t.faces){if(r.fromBufferAttribute(o,s.a),h.fromBufferAttribute(o,s.b),c.fromBufferAttribute(o,s.c),null===this.ray.intersectTriangle(r,h,c,!0,a))continue;d.copy(a),d.applyMatrix4(e.matrixWorld);const t=this.ray.origin.distanceTo(d);if(!(t<this.near||t>this.far)){i.push({distance:t,point:d.clone(),object:e,face:s});break}}else i.push(...this.intersectObject(e,s))}else console.warn("OctreeObjectData or ResultData is missing a mesh instance!");return i}intersectOctreeObjects(t,e=!0,s=[]){for(let i=0,o=t.length;i<o;i++)s.push(...this.intersectOctreeObject(t[i],e));return s.sort(((t,e)=>t.distance-e.distance)),s}}t.Octree=n,t.OctreeRaycaster=l,Object.defineProperty(t,"__esModule",{value:!0})}));
